{{/* Simple sender template - shared between client and initiator */}}

// {{ .ErrorType }} represents an HTTP error response{{ if not .IsClient }} from the {{ .PrefixLower }}{{ end }}.
// The type parameter E is the type of the parsed error body.
type {{ .ErrorType }}[E any] struct {
	StatusCode int
	Body       E
	RawBody    []byte
}

func (e *{{ .ErrorType }}[E]) Error() string {
	return fmt.Sprintf("HTTP %d", e.StatusCode)
}

// {{ .SimpleType }} wraps {{ .TypeName }} with typed responses for operations that have
// unambiguous response types. Methods return the success type directly,
// and HTTP errors are returned as *{{ .ErrorType }}[E] where E is the error type.
type {{ .SimpleType }} struct {
	*{{ .TypeName }}
}

// New{{ .SimpleType }} creates a new {{ .SimpleType }} which wraps a {{ .TypeName }}.
func New{{ .SimpleType }}({{ if .IsClient }}server string, {{ end }}opts ...{{ .OptionType }}) (*{{ .SimpleType }}, error) {
	inner, err := New{{ .TypeName }}({{ if .IsClient }}server, {{ end }}opts...)
	if err != nil {
		return nil, err
	}
	return &{{ .SimpleType }}{ {{ .TypeName }}: inner}, nil
}

{{- range .Operations }}
{{- $op := . }}
{{- $opid := .GoOperationID }}
{{- $hasParams := .HasParams }}
{{- $paramsTypeName := .ParamsTypeName }}

{{- /* Determine if this operation is "simple" - single success content type, single JSON success response */}}
{{- $simpleOp := isSimpleOperation . }}
{{- if $simpleOp }}
{{- $successResponse := simpleOperationSuccessResponse . }}
{{- $successContent := index $successResponse.Contents 0 }}
{{- $successType := goTypeForContent $successContent }}
{{- $errorResponse := errorResponseForOperation . }}

// {{ $opid }}{{ methodComment $ $op }} and returns the parsed response.
{{ if .Summary }}// {{ .Summary }}{{ end }}
{{- if $errorResponse }}
{{- $errorContent := index $errorResponse.Contents 0 }}
{{- $errorType := goTypeForContent $errorContent }}
// On success, returns the response body. On HTTP error, returns *{{ $.ErrorType }}[{{ $errorType }}].
{{- $typedBody := defaultTypedBody $op }}
func ({{ $.Receiver }} *{{ $.SimpleType }}) {{ $opid }}(ctx context.Context{{ methodParams $ $op }}{{ if $hasParams }}, params *{{ $paramsTypeName }}{{ end }}{{ if $typedBody }}, body {{ $typedBody.GoTypeName }}{{ end }}, reqEditors ...RequestEditorFn) ({{ $successType }}, error) {
	var result {{ $successType }}
{{- if $typedBody }}
	resp, err := {{ $.Receiver }}.{{ $.TypeName }}.{{ typedMethodName $op $typedBody }}(ctx{{ methodCallArgs $ $op }}{{ if $hasParams }}, params{{ end }}, body, reqEditors...)
{{- else }}
	resp, err := {{ $.Receiver }}.{{ $.TypeName }}.{{ $opid }}(ctx{{ methodCallArgs $ $op }}{{ if $hasParams }}, params{{ end }}, reqEditors...)
{{- end }}
	if err != nil {
		return result, err
	}
	defer resp.Body.Close()

	rawBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, err
	}

	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		if err := json.Unmarshal(rawBody, &result); err != nil {
			return result, err
		}
		return result, nil
	}

	// Parse error response
	var errBody {{ $errorType }}
	_ = json.Unmarshal(rawBody, &errBody) // Best effort parse
	return result, &{{ $.ErrorType }}[{{ $errorType }}]{
		StatusCode: resp.StatusCode,
		Body:       errBody,
		RawBody:    rawBody,
	}
}
{{- else }}
// On success, returns the response body. On HTTP error, returns *{{ $.ErrorType }}[struct{}].
{{- $typedBody := defaultTypedBody $op }}
func ({{ $.Receiver }} *{{ $.SimpleType }}) {{ $opid }}(ctx context.Context{{ methodParams $ $op }}{{ if $hasParams }}, params *{{ $paramsTypeName }}{{ end }}{{ if $typedBody }}, body {{ $typedBody.GoTypeName }}{{ end }}, reqEditors ...RequestEditorFn) ({{ $successType }}, error) {
	var result {{ $successType }}
{{- if $typedBody }}
	resp, err := {{ $.Receiver }}.{{ $.TypeName }}.{{ typedMethodName $op $typedBody }}(ctx{{ methodCallArgs $ $op }}{{ if $hasParams }}, params{{ end }}, body, reqEditors...)
{{- else }}
	resp, err := {{ $.Receiver }}.{{ $.TypeName }}.{{ $opid }}(ctx{{ methodCallArgs $ $op }}{{ if $hasParams }}, params{{ end }}, reqEditors...)
{{- end }}
	if err != nil {
		return result, err
	}
	defer resp.Body.Close()

	rawBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, err
	}

	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		if err := json.Unmarshal(rawBody, &result); err != nil {
			return result, err
		}
		return result, nil
	}

	// No typed error response defined
	return result, &{{ $.ErrorType }}[struct{}]{
		StatusCode: resp.StatusCode,
		RawBody:    rawBody,
	}
}
{{- end }}
{{- end }}
{{- end }}
