// Code generated by oapi-codegen; DO NOT EDIT.

package doorbadge

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"sync"

	oapiCodegenParamsPkg "github.com/oapi-codegen/oapi-codegen-exp/experimental/runtime/params"
	oapiCodegenTypesPkg "github.com/oapi-codegen/oapi-codegen-exp/experimental/runtime/types"
)

// #/components/schemas/WebhookRegistration
type WebhookRegistration struct {
	// URL to receive webhook events
	URL string `json:"url" form:"url"`
}

// ApplyDefaults sets default values for fields that are nil.
func (s *WebhookRegistration) ApplyDefaults() {
}

// #/components/schemas/WebhookRegistrationResponse
type WebhookRegistrationResponse struct {
	// Unique identifier for this webhook registration
	ID oapiCodegenTypesPkg.UUID `json:"id" form:"id"`
}

// ApplyDefaults sets default values for fields that are nil.
func (s *WebhookRegistrationResponse) ApplyDefaults() {
}

// #/components/schemas/Person
type Person struct {
	// Name of the person who badged in or out
	Name string `json:"name" form:"name"`
}

// ApplyDefaults sets default values for fields that are nil.
func (s *Person) ApplyDefaults() {
}

// #/components/schemas/Error
type Error struct {
	// Error code
	Code int32 `json:"code" form:"code"`
	// Error message
	Message string `json:"message" form:"message"`
}

// ApplyDefaults sets default values for fields that are nil.
func (s *Error) ApplyDefaults() {
}

// #/paths//api/webhook/{kind}/post/parameters/0/schema
type PostAPIWebhookKindParameter string

const (
	EnterEvent PostAPIWebhookKindParameter = "enterEvent"
	ExitEvent  PostAPIWebhookKindParameter = "exitEvent"
)

// Base64-encoded, gzip-compressed OpenAPI spec.
var openAPISpecJSON = []string{
	"H4sIAAAAAAAC/9RWTY/bNhC961cM0gI+RfLu9qTbJuvDAkGycFL0TItjaxKJZIaUvEbb/16Q1GdX3l0D",
	"RZv6ZEnDmfceh4+jDSphKIc3N+lVun6TkNrrPAFokS1plcNVuk7XCYAjV2EOd1ozvBPygLBFIZETAIm2",
	"YDIuxP+RAADcgvSBuxDIIRAscksFgiuFA4m1VtaxcGjhk0F1+3APN+kVHHFXav3NpiHP+4pQOQuMB7IO",
	"GfaaAZVD3rSoHAglAR/JxadhLXwpMdQL+ABYKKnr6gQHVBhrRmjYhvQ+jdKO9oQWRFUN9VBC5f8o5ICo",
	"ogKVxTxkVaLGHG6NKEqE66ASQMNVDqVzxuZZdjweUxG+p5oPWbfaZh/u328+ft68vU7XaenqKjHCldZn",
	"zYShrOOR/f6NlPwzFjPauvgPwDZ1LfiUw7aXRfTcu4iFLfG/Pt6OC4KirkQ4UIsqCgK+7lREOFJVwcOn",
	"z1+GVE6HVYZ1SxIl/Lr9AMcSFfpw0SfS+7jdPiHoomi421gAbfxOkFb3ciTy24yFESxq9Hjzoe7bTnaf",
	"cXgJQCoHL+LkFeP3hhhlDo4bnHywRYm1yCdvANzJYA7WManD7AOqpp6HegxjCz791LdjMsJA695peRrz",
	"nMFWaOVQuWk9YUxFRRAq+2q1mmNZogLwM+M+h9VPWaFro5Vv8SxG2qxTOAoeN2A1ILVG+/4c862u11er",
	"afpZY3W5JqdlErnA5SU25/hczGjbMVklI+69aCp3lkqj8NFg4VACMmv+L4hsfOHVExOg3gIkVujwiQnc",
	"Ib/KBrZY69b7GxjGlnRjq9PU6HpD2J2AnIX7u8WTOlZ7/Vmlf+Wk7jXXwuXQNEO95Y7+5eWOlrjQ0/+j",
	"HupvQr949KpnbpIHZKtVjEUZrH3XUCVHkWddsPm7//1gLhfpPG9s6/NtEMcJxgKpDQ0wmPorJHwk9xoF",
	"f+xr4p8VcCzgV3Q14uIF9+6zxpOud1+xmKoUBJl4TMNV70HsJXY0xennseRF9xi8g+kcJT/gON1zGtwy",
	"TpDJOS79TXQhp8HBliiRvIRRM3PfOSVF3xsEkqjC7MvdMEh2oMcTLpFk7IwL+fh74BlG4Zp4mdMM/EdR",
	"Y5wvEUw8esdSx7leAinQDLpxEXSwxQsxF1ri5LFGa8XhORZ+wVMWpBwekBe2hpS7uT57gjziOYYOwaVC",
	"xUw9/L8CAAD//+XREy3yDQAA",
}

// decodeOpenAPISpec decodes and decompresses the embedded spec.
func decodeOpenAPISpec() ([]byte, error) {
	joined := strings.Join(openAPISpecJSON, "")
	raw, err := base64.StdEncoding.DecodeString(joined)
	if err != nil {
		return nil, fmt.Errorf("decoding base64: %w", err)
	}
	r, err := gzip.NewReader(bytes.NewReader(raw))
	if err != nil {
		return nil, fmt.Errorf("creating gzip reader: %w", err)
	}
	defer r.Close()
	var out bytes.Buffer
	if _, err := out.ReadFrom(r); err != nil {
		return nil, fmt.Errorf("decompressing: %w", err)
	}
	return out.Bytes(), nil
}

// decodeOpenAPISpecCached returns a closure that caches the decoded spec.
func decodeOpenAPISpecCached() func() ([]byte, error) {
	var cached []byte
	var cachedErr error
	var once sync.Once
	return func() ([]byte, error) {
		once.Do(func() {
			cached, cachedErr = decodeOpenAPISpec()
		})
		return cached, cachedErr
	}
}

var openAPISpec = decodeOpenAPISpecCached()

// GetOpenAPISpecJSON returns the raw OpenAPI spec as JSON bytes.
func GetOpenAPISpecJSON() ([]byte, error) {
	return openAPISpec()
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Deregister a webhook
	// (DELETE /api/webhook/{id})
	DeregisterWebhook(w http.ResponseWriter, r *http.Request, id oapiCodegenTypesPkg.UUID)
	// Register a webhook
	// (POST /api/webhook/{kind})
	RegisterWebhook(w http.ResponseWriter, r *http.Request, kind string)
}

// ServerInterfaceWrapper converts HTTP requests to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

// MiddlewareFunc is a middleware function type.
type MiddlewareFunc func(http.Handler) http.Handler

// DeregisterWebhook operation middleware
func (siw *ServerInterfaceWrapper) DeregisterWebhook(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id oapiCodegenTypesPkg.UUID

	err = oapiCodegenParamsPkg.BindSimpleParam("id", oapiCodegenParamsPkg.ParamLocationPath, r.PathValue("id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeregisterWebhook(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RegisterWebhook operation middleware
func (siw *ServerInterfaceWrapper) RegisterWebhook(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "kind" -------------
	var kind string

	err = oapiCodegenParamsPkg.BindSimpleParam("kind", oapiCodegenParamsPkg.ParamLocationPath, r.PathValue("kind"), &kind)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterWebhook(w, r, kind)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

// StdHTTPServerOptions configures the StdHTTP server.
type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

// HandlerFromMuxWithBaseURL creates http.Handler with routing and a base URL.
func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options.
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("DELETE "+options.BaseURL+"/api/webhook/{id}", wrapper.DeregisterWebhook)
	m.HandleFunc("POST "+options.BaseURL+"/api/webhook/{kind}", wrapper.RegisterWebhook)
	return m
}

// UnescapedCookieParamError is returned when a cookie parameter cannot be unescaped.
type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

// UnmarshalingParamError is returned when a parameter cannot be unmarshaled.
type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

// RequiredParamError is returned when a required parameter is missing.
type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

// RequiredHeaderError is returned when a required header is missing.
type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

// InvalidParamFormatError is returned when a parameter has an invalid format.
type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

// TooManyValuesForParamError is returned when a parameter has too many values.
type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

type EnterEventJSONRequestBody = Person

type ExitEventJSONRequestBody = Person

// RequestEditorFn is the function signature for the RequestEditor callback function.
// It may already be defined if client code is also generated; this is a compatible redeclaration.
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// HttpRequestDoer performs HTTP requests.
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// WebhookInitiator sends webhook requests to target URLs.
// Unlike Client, it has no stored base URL â€” the full target URL is provided per-call.
type WebhookInitiator struct {
	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// WebhookInitiatorOption allows setting custom parameters during construction.
type WebhookInitiatorOption func(*WebhookInitiator) error

// NewWebhookInitiator creates a new WebhookInitiator with reasonable defaults.
func NewWebhookInitiator(opts ...WebhookInitiatorOption) (*WebhookInitiator, error) {
	initiator := WebhookInitiator{}
	for _, o := range opts {
		if err := o(&initiator); err != nil {
			return nil, err
		}
	}
	if initiator.Client == nil {
		initiator.Client = &http.Client{}
	}
	return &initiator, nil
}

// WithWebhookHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithWebhookHTTPClient(doer HttpRequestDoer) WebhookInitiatorOption {
	return func(p *WebhookInitiator) error {
		p.Client = doer
		return nil
	}
}

// WithWebhookRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithWebhookRequestEditorFn(fn RequestEditorFn) WebhookInitiatorOption {
	return func(p *WebhookInitiator) error {
		p.RequestEditors = append(p.RequestEditors, fn)
		return nil
	}
}

func (p *WebhookInitiator) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range p.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// WebhookInitiatorInterface is the interface specification for the webhook initiator.
type WebhookInitiatorInterface interface {
	// EnterEventWithBody sends a POST webhook request
	EnterEventWithBody(ctx context.Context, targetURL string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
	EnterEvent(ctx context.Context, targetURL string, body EnterEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
	// ExitEventWithBody sends a POST webhook request
	ExitEventWithBody(ctx context.Context, targetURL string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
	ExitEvent(ctx context.Context, targetURL string, body ExitEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

// EnterEventWithBody sends a POST webhook request
// Person entered the building
func (p *WebhookInitiator) EnterEventWithBody(ctx context.Context, targetURL string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterEventWebhookRequestWithBody(targetURL, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := p.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return p.Client.Do(req)
}

// EnterEvent sends a POST webhook request with application/json body
func (p *WebhookInitiator) EnterEvent(ctx context.Context, targetURL string, body EnterEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterEventWebhookRequest(targetURL, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := p.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return p.Client.Do(req)
}

// ExitEventWithBody sends a POST webhook request
// Person exited the building
func (p *WebhookInitiator) ExitEventWithBody(ctx context.Context, targetURL string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitEventWebhookRequestWithBody(targetURL, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := p.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return p.Client.Do(req)
}

// ExitEvent sends a POST webhook request with application/json body
func (p *WebhookInitiator) ExitEvent(ctx context.Context, targetURL string, body ExitEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitEventWebhookRequest(targetURL, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := p.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return p.Client.Do(req)
}

// NewEnterEventWebhookRequest creates a POST request for the webhook with application/json body
func NewEnterEventWebhookRequest(targetURL string, body EnterEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterEventWebhookRequestWithBody(targetURL, "application/json", bodyReader)
}

// NewEnterEventWebhookRequestWithBody creates a POST request for the webhook with any body
func NewEnterEventWebhookRequestWithBody(targetURL string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", parsedURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExitEventWebhookRequest creates a POST request for the webhook with application/json body
func NewExitEventWebhookRequest(targetURL string, body ExitEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExitEventWebhookRequestWithBody(targetURL, "application/json", bodyReader)
}

// NewExitEventWebhookRequestWithBody creates a POST request for the webhook with any body
func NewExitEventWebhookRequestWithBody(targetURL string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", parsedURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// WebhookHttpError represents an HTTP error response.
// The type parameter E is the type of the parsed error body.
type WebhookHttpError[E any] struct {
	StatusCode int
	Body       E
	RawBody    []byte
}

func (e *WebhookHttpError[E]) Error() string {
	return fmt.Sprintf("HTTP %d", e.StatusCode)
}

// SimpleWebhookInitiator wraps WebhookInitiator with typed responses for operations that have
// unambiguous response types. Methods return the success type directly,
// and HTTP errors are returned as *WebhookHttpError[E] where E is the error type.
type SimpleWebhookInitiator struct {
	*WebhookInitiator
}

// NewSimpleWebhookInitiator creates a new SimpleWebhookInitiator which wraps a WebhookInitiator.
func NewSimpleWebhookInitiator(opts ...WebhookInitiatorOption) (*SimpleWebhookInitiator, error) {
	initiator, err := NewWebhookInitiator(opts...)
	if err != nil {
		return nil, err
	}
	return &SimpleWebhookInitiator{WebhookInitiator: initiator}, nil
}

// WebhookReceiverInterface represents handlers for receiving webhook requests.
type WebhookReceiverInterface interface {
	// Person entered the building
	// HandleEnterEventWebhook handles the POST webhook request.
	HandleEnterEventWebhook(w http.ResponseWriter, r *http.Request)
	// Person exited the building
	// HandleExitEventWebhook handles the POST webhook request.
	HandleExitEventWebhook(w http.ResponseWriter, r *http.Request)
}

// WebhookReceiverMiddlewareFunc is a middleware function for webhook receiver handlers.
type WebhookReceiverMiddlewareFunc func(http.Handler) http.Handler

// EnterEventWebhookHandler returns an http.Handler for the EnterEvent webhook.
// The caller is responsible for registering this handler at the appropriate path.
func EnterEventWebhookHandler(si WebhookReceiverInterface, errHandler func(w http.ResponseWriter, r *http.Request, err error), middlewares ...WebhookReceiverMiddlewareFunc) http.Handler {
	if errHandler == nil {
		errHandler = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			si.HandleEnterEventWebhook(w, r)
		}))

		for _, middleware := range middlewares {
			handler = middleware(handler)
		}

		handler.ServeHTTP(w, r)
	})
}

// ExitEventWebhookHandler returns an http.Handler for the ExitEvent webhook.
// The caller is responsible for registering this handler at the appropriate path.
func ExitEventWebhookHandler(si WebhookReceiverInterface, errHandler func(w http.ResponseWriter, r *http.Request, err error), middlewares ...WebhookReceiverMiddlewareFunc) http.Handler {
	if errHandler == nil {
		errHandler = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			si.HandleExitEventWebhook(w, r)
		}))

		for _, middleware := range middlewares {
			handler = middleware(handler)
		}

		handler.ServeHTTP(w, r)
	})
}
