// Code generated by oapi-codegen; DO NOT EDIT.

package params

import (
	"bytes"
	"encoding"
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/oapi-codegen/oapi-codegen-exp/experimental/runtime/types"
)

// ParamLocation indicates where a parameter is located in an HTTP request.
type ParamLocation int

const (
	ParamLocationUndefined ParamLocation = iota
	ParamLocationQuery
	ParamLocationPath
	ParamLocationHeader
	ParamLocationCookie
)

// Binder is an interface for types that can bind themselves from a string value.
type Binder interface {
	Bind(value string) error
}

// primitiveToString converts a primitive value to a string representation.
// It handles basic Go types, time.Time, types.Date, and types that implement
// json.Marshaler or fmt.Stringer.
func primitiveToString(value any) (string, error) {
	// Check for known types first (time, date, uuid)
	if res, ok := marshalKnownTypes(value); ok {
		return res, nil
	}

	// Dereference pointers for optional values
	v := reflect.Indirect(reflect.ValueOf(value))
	t := v.Type()
	kind := t.Kind()

	switch kind {
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
		return strconv.FormatInt(v.Int(), 10), nil
	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
		return strconv.FormatUint(v.Uint(), 10), nil
	case reflect.Float64:
		return strconv.FormatFloat(v.Float(), 'f', -1, 64), nil
	case reflect.Float32:
		return strconv.FormatFloat(v.Float(), 'f', -1, 32), nil
	case reflect.Bool:
		if v.Bool() {
			return "true", nil
		}
		return "false", nil
	case reflect.String:
		return v.String(), nil
	case reflect.Struct:
		// Check if it's a UUID
		if u, ok := value.(uuid.UUID); ok {
			return u.String(), nil
		}
		// Check if it implements json.Marshaler
		if m, ok := value.(json.Marshaler); ok {
			buf, err := m.MarshalJSON()
			if err != nil {
				return "", fmt.Errorf("failed to marshal to JSON: %w", err)
			}
			e := json.NewDecoder(bytes.NewReader(buf))
			e.UseNumber()
			var i2 any
			if err = e.Decode(&i2); err != nil {
				return "", fmt.Errorf("failed to decode JSON: %w", err)
			}
			return primitiveToString(i2)
		}
		fallthrough
	default:
		if s, ok := value.(fmt.Stringer); ok {
			return s.String(), nil
		}
		return "", fmt.Errorf("unsupported type %s", reflect.TypeOf(value).String())
	}
}

// marshalKnownTypes checks for special types (time.Time, Date, UUID) and marshals them.
func marshalKnownTypes(value any) (string, bool) {
	v := reflect.Indirect(reflect.ValueOf(value))
	t := v.Type()

	if t.ConvertibleTo(reflect.TypeOf(time.Time{})) {
		tt := v.Convert(reflect.TypeOf(time.Time{}))
		timeVal := tt.Interface().(time.Time)
		return timeVal.Format(time.RFC3339Nano), true
	}

	if t.ConvertibleTo(reflect.TypeOf(types.Date{})) {
		d := v.Convert(reflect.TypeOf(types.Date{}))
		dateVal := d.Interface().(types.Date)
		return dateVal.Format(types.DateFormat), true
	}

	if t.ConvertibleTo(reflect.TypeOf(uuid.UUID{})) {
		u := v.Convert(reflect.TypeOf(uuid.UUID{}))
		uuidVal := u.Interface().(uuid.UUID)
		return uuidVal.String(), true
	}

	return "", false
}

// escapeParameterString escapes a parameter value based on its location.
// Query and path parameters need URL escaping; headers and cookies do not.
func escapeParameterString(value string, paramLocation ParamLocation) string {
	switch paramLocation {
	case ParamLocationQuery:
		return url.QueryEscape(value)
	case ParamLocationPath:
		return url.PathEscape(value)
	default:
		return value
	}
}

// unescapeParameterString unescapes a parameter value based on its location.
func unescapeParameterString(value string, paramLocation ParamLocation) (string, error) {
	switch paramLocation {
	case ParamLocationQuery, ParamLocationUndefined:
		return url.QueryUnescape(value)
	case ParamLocationPath:
		return url.PathUnescape(value)
	default:
		return value, nil
	}
}

// sortedKeys returns the keys of a map in sorted order.
func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// BindStringToObject binds a string value to a destination object.
// It handles primitives, encoding.TextUnmarshaler, and the Binder interface.
func BindStringToObject(src string, dst any) error {
	// Check for TextUnmarshaler
	if tu, ok := dst.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(src))
	}

	// Check for Binder interface
	if b, ok := dst.(Binder); ok {
		return b.Bind(src)
	}

	v := reflect.ValueOf(dst)
	if v.Kind() != reflect.Ptr {
		return fmt.Errorf("dst must be a pointer, got %T", dst)
	}
	v = v.Elem()

	switch v.Kind() {
	case reflect.String:
		v.SetString(src)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		i, err := strconv.ParseInt(src, 10, 64)
		if err != nil {
			return fmt.Errorf("failed to parse int: %w", err)
		}
		v.SetInt(i)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		u, err := strconv.ParseUint(src, 10, 64)
		if err != nil {
			return fmt.Errorf("failed to parse uint: %w", err)
		}
		v.SetUint(u)
	case reflect.Float32, reflect.Float64:
		f, err := strconv.ParseFloat(src, 64)
		if err != nil {
			return fmt.Errorf("failed to parse float: %w", err)
		}
		v.SetFloat(f)
	case reflect.Bool:
		b, err := strconv.ParseBool(src)
		if err != nil {
			return fmt.Errorf("failed to parse bool: %w", err)
		}
		v.SetBool(b)
	default:
		// Try JSON unmarshal as a fallback
		return json.Unmarshal([]byte(src), dst)
	}
	return nil
}

// bindSplitPartsToDestinationArray binds a slice of string parts to a destination slice.
func bindSplitPartsToDestinationArray(parts []string, dest any) error {
	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	newArray := reflect.MakeSlice(t, len(parts), len(parts))
	for i, p := range parts {
		err := BindStringToObject(p, newArray.Index(i).Addr().Interface())
		if err != nil {
			return fmt.Errorf("error setting array element: %w", err)
		}
	}
	v.Set(newArray)
	return nil
}

// bindSplitPartsToDestinationStruct binds string parts to a destination struct via JSON.
func bindSplitPartsToDestinationStruct(paramName string, parts []string, explode bool, dest any) error {
	var fields []string
	if explode {
		fields = make([]string, len(parts))
		for i, property := range parts {
			propertyParts := strings.Split(property, "=")
			if len(propertyParts) != 2 {
				return fmt.Errorf("parameter '%s' has invalid exploded format", paramName)
			}
			fields[i] = "\"" + propertyParts[0] + "\":\"" + propertyParts[1] + "\""
		}
	} else {
		if len(parts)%2 != 0 {
			return fmt.Errorf("parameter '%s' has invalid format, property/values need to be pairs", paramName)
		}
		fields = make([]string, len(parts)/2)
		for i := 0; i < len(parts); i += 2 {
			key := parts[i]
			value := parts[i+1]
			fields[i/2] = "\"" + key + "\":\"" + value + "\""
		}
	}
	jsonParam := "{" + strings.Join(fields, ",") + "}"
	return json.Unmarshal([]byte(jsonParam), dest)
}

// BindDeepObjectParam binds a deepObject-style parameter to a destination.
// DeepObject style is only valid for query parameters and must be exploded.
// Objects: ?paramName[key1]=value1&paramName[key2]=value2 -> struct{Key1, Key2}
// Nested: ?paramName[outer][inner]=value -> struct{Outer: {Inner: value}}
func BindDeepObjectParam(paramName string, queryParams url.Values, dest any) error {
	return UnmarshalDeepObject(dest, paramName, queryParams)
}

// UnmarshalDeepObject unmarshals deepObject-style query parameters to a destination.
func UnmarshalDeepObject(dst any, paramName string, params url.Values) error {
	// Find all params that look like "paramName[..."
	var fieldNames []string
	var fieldValues []string
	searchStr := paramName + "["

	for pName, pValues := range params {
		if strings.HasPrefix(pName, searchStr) {
			// Trim the parameter name prefix
			pName = pName[len(paramName):]
			fieldNames = append(fieldNames, pName)
			if len(pValues) != 1 {
				return fmt.Errorf("%s has multiple values", pName)
			}
			fieldValues = append(fieldValues, pValues[0])
		}
	}

	// Reconstruct subscript paths
	paths := make([][]string, len(fieldNames))
	for i, path := range fieldNames {
		path = strings.TrimLeft(path, "[")
		path = strings.TrimRight(path, "]")
		paths[i] = strings.Split(path, "][")
	}

	fieldPaths := makeFieldOrValue(paths, fieldValues)
	return assignPathValues(dst, fieldPaths)
}

type fieldOrValue struct {
	fields map[string]fieldOrValue
	value  string
}

func (f *fieldOrValue) appendPathValue(path []string, value string) {
	fieldName := path[0]
	if len(path) == 1 {
		f.fields[fieldName] = fieldOrValue{value: value}
		return
	}

	pv, found := f.fields[fieldName]
	if !found {
		pv = fieldOrValue{
			fields: make(map[string]fieldOrValue),
		}
		f.fields[fieldName] = pv
	}
	pv.appendPathValue(path[1:], value)
}

func makeFieldOrValue(paths [][]string, values []string) fieldOrValue {
	f := fieldOrValue{
		fields: make(map[string]fieldOrValue),
	}
	for i := range paths {
		f.appendPathValue(paths[i], values[i])
	}
	return f
}

func getFieldName(f reflect.StructField) string {
	n := f.Name
	tag, found := f.Tag.Lookup("json")
	if found {
		parts := strings.Split(tag, ",")
		if parts[0] != "" {
			n = parts[0]
		}
	}
	return n
}

func fieldIndicesByJsonTag(i any) (map[string]int, error) {
	t := reflect.TypeOf(i)
	if t.Kind() != reflect.Struct {
		return nil, errors.New("expected a struct as input")
	}

	n := t.NumField()
	fieldMap := make(map[string]int)
	for i := 0; i < n; i++ {
		field := t.Field(i)
		fieldName := getFieldName(field)
		fieldMap[fieldName] = i
	}
	return fieldMap, nil
}

func assignPathValues(dst any, pathValues fieldOrValue) error {
	v := reflect.ValueOf(dst)
	iv := reflect.Indirect(v)
	it := iv.Type()

	switch it.Kind() {
	case reflect.Map:
		dstMap := reflect.MakeMap(iv.Type())
		for key, value := range pathValues.fields {
			dstKey := reflect.ValueOf(key)
			dstVal := reflect.New(iv.Type().Elem())
			err := assignPathValues(dstVal.Interface(), value)
			if err != nil {
				return fmt.Errorf("error binding map: %w", err)
			}
			dstMap.SetMapIndex(dstKey, dstVal.Elem())
		}
		iv.Set(dstMap)
		return nil

	case reflect.Slice:
		sliceLength := len(pathValues.fields)
		dstSlice := reflect.MakeSlice(it, sliceLength, sliceLength)
		err := assignDeepObjectSlice(dstSlice, pathValues)
		if err != nil {
			return fmt.Errorf("error assigning slice: %w", err)
		}
		iv.Set(dstSlice)
		return nil

	case reflect.Struct:
		// Check for Binder interface
		if dst, isBinder := v.Interface().(Binder); isBinder {
			return dst.Bind(pathValues.value)
		}

		// Handle Date type
		if it.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			var date types.Date
			var err error
			date.Time, err = time.Parse(types.DateFormat, pathValues.value)
			if err != nil {
				return fmt.Errorf("invalid date format: %w", err)
			}
			dst := iv
			if it != reflect.TypeOf(types.Date{}) {
				ivPtr := iv.Addr()
				aPtr := ivPtr.Convert(reflect.TypeOf(&types.Date{}))
				dst = reflect.Indirect(aPtr)
			}
			dst.Set(reflect.ValueOf(date))
			return nil
		}

		// Handle time.Time type
		if it.ConvertibleTo(reflect.TypeOf(time.Time{})) {
			tm, err := time.Parse(time.RFC3339Nano, pathValues.value)
			if err != nil {
				tm, err = time.Parse(types.DateFormat, pathValues.value)
				if err != nil {
					return fmt.Errorf("error parsing '%s' as RFC3339 or date: %w", pathValues.value, err)
				}
			}
			dst := iv
			if it != reflect.TypeOf(time.Time{}) {
				ivPtr := iv.Addr()
				aPtr := ivPtr.Convert(reflect.TypeOf(&time.Time{}))
				dst = reflect.Indirect(aPtr)
			}
			dst.Set(reflect.ValueOf(tm))
			return nil
		}

		// Regular struct
		fieldMap, err := fieldIndicesByJsonTag(iv.Interface())
		if err != nil {
			return fmt.Errorf("failed enumerating fields: %w", err)
		}
		for _, fieldName := range sortedFieldOrValueKeys(pathValues.fields) {
			fieldValue := pathValues.fields[fieldName]
			fieldIndex, found := fieldMap[fieldName]
			if !found {
				return fmt.Errorf("field [%s] is not present in destination object", fieldName)
			}
			field := iv.Field(fieldIndex)
			err = assignPathValues(field.Addr().Interface(), fieldValue)
			if err != nil {
				return fmt.Errorf("error assigning field [%s]: %w", fieldName, err)
			}
		}
		return nil

	case reflect.Ptr:
		dstVal := reflect.New(it.Elem())
		dstPtr := dstVal.Interface()
		err := assignPathValues(dstPtr, pathValues)
		iv.Set(dstVal)
		return err

	case reflect.Bool:
		val, err := strconv.ParseBool(pathValues.value)
		if err != nil {
			return fmt.Errorf("expected a valid bool, got %s", pathValues.value)
		}
		iv.SetBool(val)
		return nil

	case reflect.Float32:
		val, err := strconv.ParseFloat(pathValues.value, 32)
		if err != nil {
			return fmt.Errorf("expected a valid float, got %s", pathValues.value)
		}
		iv.SetFloat(val)
		return nil

	case reflect.Float64:
		val, err := strconv.ParseFloat(pathValues.value, 64)
		if err != nil {
			return fmt.Errorf("expected a valid float, got %s", pathValues.value)
		}
		iv.SetFloat(val)
		return nil

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		val, err := strconv.ParseInt(pathValues.value, 10, 64)
		if err != nil {
			return fmt.Errorf("expected a valid int, got %s", pathValues.value)
		}
		iv.SetInt(val)
		return nil

	case reflect.String:
		iv.SetString(pathValues.value)
		return nil

	default:
		return errors.New("unhandled type: " + it.String())
	}
}

func assignDeepObjectSlice(dst reflect.Value, pathValues fieldOrValue) error {
	nValues := len(pathValues.fields)
	values := make([]string, nValues)
	for i := 0; i < nValues; i++ {
		indexStr := strconv.Itoa(i)
		fv, found := pathValues.fields[indexStr]
		if !found {
			return errors.New("array deepObjects must have consecutive indices")
		}
		values[i] = fv.value
	}

	for i := 0; i < nValues; i++ {
		dstElem := dst.Index(i).Addr()
		err := assignPathValues(dstElem.Interface(), fieldOrValue{value: values[i]})
		if err != nil {
			return fmt.Errorf("error binding array: %w", err)
		}
	}
	return nil
}

func sortedFieldOrValueKeys(m map[string]fieldOrValue) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// BindFormParam binds a form-style parameter without explode to a destination.
// Form style is the default for query and cookie parameters.
// This function handles a single query parameter value (not url.Values).
// Arrays: a,b,c -> []string{"a", "b", "c"}
// Objects: key1,value1,key2,value2 -> struct{Key1, Key2}
func BindFormParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(value))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		parts := strings.Split(value, ",")
		return bindSplitPartsToDestinationStruct(paramName, parts, false, dest)
	case reflect.Slice:
		parts := strings.Split(value, ",")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(value, dest)
	}
}

// BindFormExplodeParam binds a form-style parameter with explode to a destination.
// Form style is the default for query and cookie parameters.
// This handles the exploded case where arrays come as multiple query params.
// Arrays: ?param=a&param=b -> []string{"a", "b"} (values passed as slice)
// Objects: ?key1=value1&key2=value2 -> struct{Key1, Key2} (queryParams passed)
func BindFormExplodeParam(paramName string, required bool, queryParams url.Values, dest any) error {
	dv := reflect.Indirect(reflect.ValueOf(dest))
	v := dv
	var output any

	if required {
		output = dest
	} else {
		// For optional parameters, allocate if nil
		if v.IsNil() {
			t := v.Type()
			newValue := reflect.New(t.Elem())
			output = newValue.Interface()
		} else {
			output = v.Interface()
		}
		v = reflect.Indirect(reflect.ValueOf(output))
	}

	t := v.Type()
	k := t.Kind()

	values, found := queryParams[paramName]

	switch k {
	case reflect.Slice:
		if !found {
			if required {
				return fmt.Errorf("query parameter '%s' is required", paramName)
			}
			return nil
		}
		err := bindSplitPartsToDestinationArray(values, output)
		if err != nil {
			return err
		}
	case reflect.Struct:
		// For exploded objects, fields are spread across query params
		fieldsPresent, err := bindParamsToExplodedObject(paramName, queryParams, output)
		if err != nil {
			return err
		}
		if !fieldsPresent {
			return nil
		}
	default:
		// Primitive
		if len(values) == 0 {
			if required {
				return fmt.Errorf("query parameter '%s' is required", paramName)
			}
			return nil
		}
		if len(values) != 1 {
			return fmt.Errorf("multiple values for single value parameter '%s'", paramName)
		}
		if !found {
			if required {
				return fmt.Errorf("query parameter '%s' is required", paramName)
			}
			return nil
		}
		err := BindStringToObject(values[0], output)
		if err != nil {
			return err
		}
	}

	if !required {
		dv.Set(reflect.ValueOf(output))
	}
	return nil
}

// bindParamsToExplodedObject binds query params to struct fields for exploded objects.
func bindParamsToExplodedObject(paramName string, values url.Values, dest any) (bool, error) {
	binder, v, t := indirectBinder(dest)
	if binder != nil {
		_, found := values[paramName]
		if !found {
			return false, nil
		}
		return true, BindStringToObject(values.Get(paramName), dest)
	}
	if t.Kind() != reflect.Struct {
		return false, fmt.Errorf("unmarshaling query arg '%s' into wrong type", paramName)
	}

	fieldsPresent := false
	for i := 0; i < t.NumField(); i++ {
		fieldT := t.Field(i)
		if !v.Field(i).CanSet() {
			continue
		}

		tag := fieldT.Tag.Get("json")
		fieldName := fieldT.Name
		if tag != "" {
			tagParts := strings.Split(tag, ",")
			if tagParts[0] != "" {
				fieldName = tagParts[0]
			}
		}

		fieldVal, found := values[fieldName]
		if found {
			if len(fieldVal) != 1 {
				return false, fmt.Errorf("field '%s' specified multiple times for param '%s'", fieldName, paramName)
			}
			err := BindStringToObject(fieldVal[0], v.Field(i).Addr().Interface())
			if err != nil {
				return false, fmt.Errorf("could not bind query arg '%s': %w", paramName, err)
			}
			fieldsPresent = true
		}
	}
	return fieldsPresent, nil
}

// indirectBinder checks if dest implements Binder and returns reflect values.
func indirectBinder(dest any) (any, reflect.Value, reflect.Type) {
	v := reflect.ValueOf(dest)
	if v.Type().NumMethod() > 0 && v.CanInterface() {
		if u, ok := v.Interface().(Binder); ok {
			return u, reflect.Value{}, nil
		}
	}
	v = reflect.Indirect(v)
	t := v.Type()
	// Handle special types like time.Time and Date
	if t.ConvertibleTo(reflect.TypeOf(time.Time{})) {
		return dest, reflect.Value{}, nil
	}
	if t.ConvertibleTo(reflect.TypeOf(types.Date{})) {
		return dest, reflect.Value{}, nil
	}
	return nil, v, t
}

// BindLabelParam binds a label-style parameter without explode to a destination.
// Label style values are prefixed with a dot.
// Primitives: .value -> "value"
// Arrays: .a,b,c -> []string{"a", "b", "c"}
// Objects: .key1,value1,key2,value2 -> struct{Key1, Key2}
func BindLabelParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Label style requires leading dot
	if value[0] != '.' {
		return fmt.Errorf("invalid format for label parameter '%s', should start with '.'", paramName)
	}

	// Strip the leading dot and split on comma
	stripped := value[1:]

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(stripped))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		parts := strings.Split(stripped, ",")
		return bindSplitPartsToDestinationStruct(paramName, parts, false, dest)
	case reflect.Slice:
		parts := strings.Split(stripped, ",")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(stripped, dest)
	}
}

// BindLabelExplodeParam binds a label-style parameter with explode to a destination.
// Label style values are prefixed with a dot.
// Primitives: .value -> "value"
// Arrays: .a.b.c -> []string{"a", "b", "c"}
// Objects: .key1=value1.key2=value2 -> struct{Key1, Key2}
func BindLabelExplodeParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Label style requires leading dot
	if value[0] != '.' {
		return fmt.Errorf("invalid format for label parameter '%s', should start with '.'", paramName)
	}

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(value[1:]))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		// Split on dot (skip first empty part)
		parts := strings.Split(value, ".")
		if parts[0] != "" {
			return fmt.Errorf("invalid format for label parameter '%s', should start with '.'", paramName)
		}
		return bindSplitPartsToDestinationStruct(paramName, parts[1:], true, dest)
	case reflect.Slice:
		// Split on dot (skip first empty part)
		parts := strings.Split(value, ".")
		if parts[0] != "" {
			return fmt.Errorf("invalid format for label parameter '%s', should start with '.'", paramName)
		}
		return bindSplitPartsToDestinationArray(parts[1:], dest)
	default:
		return BindStringToObject(value[1:], dest)
	}
}

// BindMatrixParam binds a matrix-style parameter without explode to a destination.
// Matrix style values are prefixed with ;paramName=.
// Primitives: ;paramName=value -> "value"
// Arrays: ;paramName=a,b,c -> []string{"a", "b", "c"}
// Objects: ;paramName=key1,value1,key2,value2 -> struct{Key1, Key2}
func BindMatrixParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Matrix style requires ;paramName= prefix
	prefix := ";" + paramName + "="
	if !strings.HasPrefix(value, prefix) {
		return fmt.Errorf("expected parameter '%s' to start with %s", paramName, prefix)
	}

	// Strip the prefix
	stripped := strings.TrimPrefix(value, prefix)

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(stripped))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		parts := strings.Split(stripped, ",")
		return bindSplitPartsToDestinationStruct(paramName, parts, false, dest)
	case reflect.Slice:
		parts := strings.Split(stripped, ",")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(stripped, dest)
	}
}

// BindMatrixExplodeParam binds a matrix-style parameter with explode to a destination.
// Matrix style values are prefixed with semicolons.
// Primitives: ;paramName=value -> "value"
// Arrays: ;paramName=a;paramName=b;paramName=c -> []string{"a", "b", "c"}
// Objects: ;key1=value1;key2=value2 -> struct{Key1, Key2}
func BindMatrixExplodeParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Break up on semicolon
	parts := strings.Split(value, ";")
	// First part should be empty since we start with ;
	if parts[0] != "" {
		return fmt.Errorf("invalid format for matrix parameter '%s', should start with ';'", paramName)
	}
	parts = parts[1:]

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		// For primitives, should be ;paramName=value
		if len(parts) == 1 {
			kv := strings.SplitN(parts[0], "=", 2)
			if len(kv) == 2 && kv[0] == paramName {
				return tu.UnmarshalText([]byte(kv[1]))
			}
		}
		return fmt.Errorf("invalid format for matrix parameter '%s'", paramName)
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		// For objects, we have key1=value1, key2=value2
		return bindSplitPartsToDestinationStruct(paramName, parts, true, dest)
	case reflect.Slice:
		// For arrays, strip paramName= prefix from each part
		prefix := paramName + "="
		values := make([]string, len(parts))
		for i, part := range parts {
			values[i] = strings.TrimPrefix(part, prefix)
		}
		return bindSplitPartsToDestinationArray(values, dest)
	default:
		// Primitive: ;paramName=value
		if len(parts) == 1 {
			kv := strings.SplitN(parts[0], "=", 2)
			if len(kv) == 2 && kv[0] == paramName {
				return BindStringToObject(kv[1], dest)
			}
		}
		return fmt.Errorf("invalid format for matrix parameter '%s'", paramName)
	}
}

// BindPipeDelimitedParam binds a pipeDelimited-style parameter without explode.
// Pipe-delimited style uses pipe as the separator.
// Arrays: a|b|c -> []string{"a", "b", "c"}
func BindPipeDelimitedParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(value))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Slice:
		parts := strings.Split(value, "|")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(value, dest)
	}
}

// BindPipeDelimitedExplodeParam binds a pipeDelimited-style parameter with explode.
// When exploded, arrays come as multiple query params (same as form explode).
// Arrays: ?param=a&param=b -> []string{"a", "b"}
func BindPipeDelimitedExplodeParam(paramName string, required bool, queryParams url.Values, dest any) error {
	// Exploded pipe-delimited is same as exploded form
	return BindFormExplodeParam(paramName, required, queryParams, dest)
}

// BindSimpleParam binds a simple-style parameter without explode to a destination.
// Simple style is the default for path and header parameters.
// Arrays: a,b,c -> []string{"a", "b", "c"}
// Objects: key1,value1,key2,value2 -> struct{Key1, Key2}
func BindSimpleParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(value))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		// Split on comma and bind as key,value pairs
		parts := strings.Split(value, ",")
		return bindSplitPartsToDestinationStruct(paramName, parts, false, dest)
	case reflect.Slice:
		parts := strings.Split(value, ",")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(value, dest)
	}
}

// BindSimpleExplodeParam binds a simple-style parameter with explode to a destination.
// Simple style is the default for path and header parameters.
// Arrays: a,b,c -> []string{"a", "b", "c"} (same as non-explode)
// Objects: key1=value1,key2=value2 -> struct{Key1, Key2}
func BindSimpleExplodeParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(value))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		// Split on comma and bind as key=value pairs
		parts := strings.Split(value, ",")
		return bindSplitPartsToDestinationStruct(paramName, parts, true, dest)
	case reflect.Slice:
		parts := strings.Split(value, ",")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(value, dest)
	}
}

// BindSpaceDelimitedParam binds a spaceDelimited-style parameter without explode.
// Space-delimited style uses space as the separator.
// Arrays: a b c -> []string{"a", "b", "c"}
func BindSpaceDelimitedParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(value))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Slice:
		parts := strings.Split(value, " ")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(value, dest)
	}
}

// BindSpaceDelimitedExplodeParam binds a spaceDelimited-style parameter with explode.
// When exploded, arrays come as multiple query params (same as form explode).
// Arrays: ?param=a&param=b -> []string{"a", "b"}
func BindSpaceDelimitedExplodeParam(paramName string, required bool, queryParams url.Values, dest any) error {
	// Exploded space-delimited is same as exploded form
	return BindFormExplodeParam(paramName, required, queryParams, dest)
}

// StyleDeepObjectParam serializes a value using deepObject style.
// DeepObject style is only valid for query parameters with object values and must be exploded.
// Objects: paramName[key1]=value1&paramName[key2]=value2
// Nested: paramName[outer][inner]=value
func StyleDeepObjectParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// deepObject always requires explode=true
	return MarshalDeepObject(value, paramName)
}

// MarshalDeepObject marshals an object to deepObject style query parameters.
func MarshalDeepObject(i any, paramName string) (string, error) {
	// Marshal to JSON first to handle all field annotations
	buf, err := json.Marshal(i)
	if err != nil {
		return "", fmt.Errorf("failed to marshal input to JSON: %w", err)
	}
	var i2 any
	err = json.Unmarshal(buf, &i2)
	if err != nil {
		return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
	}
	fields, err := marshalDeepObjectRecursive(i2, nil)
	if err != nil {
		return "", fmt.Errorf("error traversing JSON structure: %w", err)
	}

	// Prefix the param name to each subscripted field
	for idx := range fields {
		fields[idx] = paramName + fields[idx]
	}
	return strings.Join(fields, "&"), nil
}

func marshalDeepObjectRecursive(in any, path []string) ([]string, error) {
	var result []string

	switch t := in.(type) {
	case []any:
		// Arrays use numerical subscripts [0], [1], etc.
		for i, iface := range t {
			newPath := append(path, strconv.Itoa(i))
			fields, err := marshalDeepObjectRecursive(iface, newPath)
			if err != nil {
				return nil, fmt.Errorf("error traversing array: %w", err)
			}
			result = append(result, fields...)
		}
	case map[string]any:
		// Maps use key subscripts [key1], [key2], etc.
		keys := make([]string, 0, len(t))
		for k := range t {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, k := range keys {
			newPath := append(path, k)
			fields, err := marshalDeepObjectRecursive(t[k], newPath)
			if err != nil {
				return nil, fmt.Errorf("error traversing map: %w", err)
			}
			result = append(result, fields...)
		}
	default:
		// Concrete value: turn path into [a][b][c] format
		prefix := "[" + strings.Join(path, "][") + "]"
		result = []string{
			prefix + fmt.Sprintf("=%v", t),
		}
	}
	return result, nil
}

// StyleFormParam serializes a value using form style (RFC 6570) without exploding.
// Form style is the default for query and cookie parameters.
// Primitives: paramName=value
// Arrays: paramName=a,b,c
// Objects: paramName=key1,value1,key2,value2
func StyleFormParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf("%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleFormSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleFormStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleFormMap(paramName, paramLocation, value)
	default:
		return styleFormPrimitive(paramName, paramLocation, value)
	}
}

func styleFormPrimitive(paramName string, paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func styleFormSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Form without explode: paramName=a,b,c
	prefix := fmt.Sprintf("%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, ","), nil
}

func styleFormStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return fmt.Sprintf("%s=%s", paramName, escapeParameterString(timeVal, paramLocation)), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleFormParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Form style without explode: paramName=key1,value1,key2,value2
	prefix := fmt.Sprintf("%s=", paramName)
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return prefix + strings.Join(parts, ","), nil
}

func styleFormMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Form style without explode: paramName=key1,value1,key2,value2
	prefix := fmt.Sprintf("%s=", paramName)
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return prefix + strings.Join(parts, ","), nil
}

// StyleFormExplodeParam serializes a value using form style (RFC 6570) with exploding.
// Form style is the default for query and cookie parameters.
// Primitives: paramName=value
// Arrays: paramName=a&paramName=b&paramName=c
// Objects: key1=value1&key2=value2
func StyleFormExplodeParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf("%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleFormExplodeSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleFormExplodeStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleFormExplodeMap(paramName, paramLocation, value)
	default:
		return styleFormExplodePrimitive(paramName, paramLocation, value)
	}
}

func styleFormExplodePrimitive(paramName string, paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func styleFormExplodeSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Form with explode: paramName=a&paramName=b&paramName=c
	prefix := fmt.Sprintf("%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, "&"+prefix), nil
}

func styleFormExplodeStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return fmt.Sprintf("%s=%s", paramName, escapeParameterString(timeVal, paramLocation)), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleFormExplodeParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Form style with explode: key1=value1&key2=value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k+"="+v)
	}
	return strings.Join(parts, "&"), nil
}

func styleFormExplodeMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Form style with explode: key1=value1&key2=value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k+"="+v)
	}
	return strings.Join(parts, "&"), nil
}

// StyleLabelParam serializes a value using label style (RFC 6570) without exploding.
// Label style prefixes values with a dot.
// Primitives: .value
// Arrays: .a,b,c
// Objects: .key1,value1,key2,value2
func StyleLabelParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return "." + escapeParameterString(string(b), paramLocation), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleLabelSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleLabelStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleLabelMap(paramName, paramLocation, value)
	default:
		return styleLabelPrimitive(paramLocation, value)
	}
}

func styleLabelPrimitive(paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return "." + escapeParameterString(strVal, paramLocation), nil
}

func styleLabelSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Label without explode: .a,b,c
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return "." + strings.Join(parts, ","), nil
}

func styleLabelStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return "." + escapeParameterString(timeVal, paramLocation), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleLabelParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Label style without explode: .key1,value1,key2,value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return "." + strings.Join(parts, ","), nil
}

func styleLabelMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Label style without explode: .key1,value1,key2,value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return "." + strings.Join(parts, ","), nil
}

// StyleLabelExplodeParam serializes a value using label style (RFC 6570) with exploding.
// Label style prefixes values with a dot.
// Primitives: .value
// Arrays: .a.b.c
// Objects: .key1=value1.key2=value2
func StyleLabelExplodeParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return "." + escapeParameterString(string(b), paramLocation), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleLabelExplodeSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleLabelExplodeStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleLabelExplodeMap(paramName, paramLocation, value)
	default:
		return styleLabelExplodePrimitive(paramLocation, value)
	}
}

func styleLabelExplodePrimitive(paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return "." + escapeParameterString(strVal, paramLocation), nil
}

func styleLabelExplodeSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Label with explode: .a.b.c
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return "." + strings.Join(parts, "."), nil
}

func styleLabelExplodeStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return "." + escapeParameterString(timeVal, paramLocation), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleLabelExplodeParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Label style with explode: .key1=value1.key2=value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k+"="+v)
	}
	return "." + strings.Join(parts, "."), nil
}

func styleLabelExplodeMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Label style with explode: .key1=value1.key2=value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k+"="+v)
	}
	return "." + strings.Join(parts, "."), nil
}

// StyleMatrixParam serializes a value using matrix style (RFC 6570) without exploding.
// Matrix style prefixes values with ;paramName=.
// Primitives: ;paramName=value
// Arrays: ;paramName=a,b,c
// Objects: ;paramName=key1,value1,key2,value2
func StyleMatrixParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleMatrixSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleMatrixStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleMatrixMap(paramName, paramLocation, value)
	default:
		return styleMatrixPrimitive(paramName, paramLocation, value)
	}
}

func styleMatrixPrimitive(paramName string, paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func styleMatrixSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Matrix without explode: ;paramName=a,b,c
	prefix := fmt.Sprintf(";%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, ","), nil
}

func styleMatrixStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(timeVal, paramLocation)), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleMatrixParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Matrix style without explode: ;paramName=key1,value1,key2,value2
	prefix := fmt.Sprintf(";%s=", paramName)
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return prefix + strings.Join(parts, ","), nil
}

func styleMatrixMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Matrix style without explode: ;paramName=key1,value1,key2,value2
	prefix := fmt.Sprintf(";%s=", paramName)
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return prefix + strings.Join(parts, ","), nil
}

// StyleMatrixExplodeParam serializes a value using matrix style (RFC 6570) with exploding.
// Matrix style prefixes values with ;paramName=.
// Primitives: ;paramName=value
// Arrays: ;paramName=a;paramName=b;paramName=c
// Objects: ;key1=value1;key2=value2
func StyleMatrixExplodeParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleMatrixExplodeSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleMatrixExplodeStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleMatrixExplodeMap(paramName, paramLocation, value)
	default:
		return styleMatrixExplodePrimitive(paramName, paramLocation, value)
	}
}

func styleMatrixExplodePrimitive(paramName string, paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func styleMatrixExplodeSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Matrix with explode: ;paramName=a;paramName=b;paramName=c
	prefix := fmt.Sprintf(";%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, prefix), nil
}

func styleMatrixExplodeStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(timeVal, paramLocation)), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleMatrixExplodeParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Matrix style with explode: ;key1=value1;key2=value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k+"="+v)
	}
	return ";" + strings.Join(parts, ";"), nil
}

func styleMatrixExplodeMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Matrix style with explode: ;key1=value1;key2=value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k+"="+v)
	}
	return ";" + strings.Join(parts, ";"), nil
}

// StylePipeDelimitedParam serializes a value using pipeDelimited style without exploding.
// Pipe-delimited style is used for query parameters with array values.
// Arrays: paramName=a|b|c
// Note: Only valid for arrays; objects should use other styles.
func StylePipeDelimitedParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf("%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return stylePipeDelimitedSlice(paramName, paramLocation, sliceVal)
	default:
		// For primitives, fall back to form style
		return stylePipeDelimitedPrimitive(paramName, paramLocation, value)
	}
}

func stylePipeDelimitedPrimitive(paramName string, paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func stylePipeDelimitedSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Pipe-delimited without explode: paramName=a|b|c
	prefix := fmt.Sprintf("%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, "|"), nil
}

// StylePipeDelimitedExplodeParam serializes a value using pipeDelimited style with exploding.
// Pipe-delimited style is used for query parameters with array values.
// Arrays: paramName=a&paramName=b&paramName=c (same as form explode)
// Note: Only valid for arrays; objects should use other styles.
func StylePipeDelimitedExplodeParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf("%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return stylePipeDelimitedExplodeSlice(paramName, paramLocation, sliceVal)
	default:
		// For primitives, fall back to form style
		return stylePipeDelimitedExplodePrimitive(paramName, paramLocation, value)
	}
}

func stylePipeDelimitedExplodePrimitive(paramName string, paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func stylePipeDelimitedExplodeSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Pipe-delimited with explode: paramName=a&paramName=b&paramName=c
	prefix := fmt.Sprintf("%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, "&"+prefix), nil
}

// StyleSimpleParam serializes a value using simple style (RFC 6570) without exploding.
// Simple style is the default for path and header parameters.
// Arrays are comma-separated: a,b,c
// Objects are key,value pairs: key1,value1,key2,value2
func StyleSimpleParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return escapeParameterString(string(b), paramLocation), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleSimpleSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleSimpleStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleSimpleMap(paramName, paramLocation, value)
	default:
		return styleSimplePrimitive(paramLocation, value)
	}
}

func styleSimplePrimitive(paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return escapeParameterString(strVal, paramLocation), nil
}

func styleSimpleSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return strings.Join(parts, ","), nil
}

func styleSimpleStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return escapeParameterString(timeVal, paramLocation), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleSimpleParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Simple style without explode: key1,value1,key2,value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return strings.Join(parts, ","), nil
}

func styleSimpleMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Simple style without explode: key1,value1,key2,value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return strings.Join(parts, ","), nil
}

// structToFieldDict converts a struct to a map of field names to string values.
func structToFieldDict(value any) (map[string]string, error) {
	v := reflect.ValueOf(value)
	t := reflect.TypeOf(value)
	fieldDict := make(map[string]string)

	for i := 0; i < t.NumField(); i++ {
		fieldT := t.Field(i)
		tag := fieldT.Tag.Get("json")
		fieldName := fieldT.Name
		if tag != "" {
			tagParts := strings.Split(tag, ",")
			if tagParts[0] != "" {
				fieldName = tagParts[0]
			}
		}
		f := v.Field(i)

		// Skip nil optional fields
		if f.Type().Kind() == reflect.Ptr && f.IsNil() {
			continue
		}
		str, err := primitiveToString(f.Interface())
		if err != nil {
			return nil, fmt.Errorf("error formatting field '%s': %w", fieldName, err)
		}
		fieldDict[fieldName] = str
	}
	return fieldDict, nil
}

// StyleSimpleExplodeParam serializes a value using simple style (RFC 6570) with exploding.
// Simple style is the default for path and header parameters.
// Arrays are comma-separated: a,b,c (same as non-explode)
// Objects are key=value pairs: key1=value1,key2=value2
func StyleSimpleExplodeParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return escapeParameterString(string(b), paramLocation), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleSimpleExplodeSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleSimpleExplodeStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleSimpleExplodeMap(paramName, paramLocation, value)
	default:
		return styleSimpleExplodePrimitive(paramLocation, value)
	}
}

func styleSimpleExplodePrimitive(paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return escapeParameterString(strVal, paramLocation), nil
}

func styleSimpleExplodeSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Exploded simple array is same as non-exploded: comma-separated
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return strings.Join(parts, ","), nil
}

func styleSimpleExplodeStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return escapeParameterString(timeVal, paramLocation), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleSimpleExplodeParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Simple style with explode: key1=value1,key2=value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k+"="+v)
	}
	return strings.Join(parts, ","), nil
}

func styleSimpleExplodeMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Simple style with explode: key1=value1,key2=value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k+"="+v)
	}
	return strings.Join(parts, ","), nil
}

// StyleSpaceDelimitedParam serializes a value using spaceDelimited style without exploding.
// Space-delimited style is used for query parameters with array values.
// Arrays: paramName=a b c (space-separated)
// Note: Only valid for arrays; objects should use other styles.
func StyleSpaceDelimitedParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf("%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleSpaceDelimitedSlice(paramName, paramLocation, sliceVal)
	default:
		// For primitives, fall back to form style
		return styleSpaceDelimitedPrimitive(paramName, paramLocation, value)
	}
}

func styleSpaceDelimitedPrimitive(paramName string, paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func styleSpaceDelimitedSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Space-delimited without explode: paramName=a b c (space becomes %20 when encoded)
	prefix := fmt.Sprintf("%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, " "), nil
}

// StyleSpaceDelimitedExplodeParam serializes a value using spaceDelimited style with exploding.
// Space-delimited style is used for query parameters with array values.
// Arrays: paramName=a&paramName=b&paramName=c (same as form explode)
// Note: Only valid for arrays; objects should use other styles.
func StyleSpaceDelimitedExplodeParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(types.Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf("%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleSpaceDelimitedExplodeSlice(paramName, paramLocation, sliceVal)
	default:
		// For primitives, fall back to form style
		return styleSpaceDelimitedExplodePrimitive(paramName, paramLocation, value)
	}
}

func styleSpaceDelimitedExplodePrimitive(paramName string, paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func styleSpaceDelimitedExplodeSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	// Space-delimited with explode: paramName=a&paramName=b&paramName=c
	prefix := fmt.Sprintf("%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, "&"+prefix), nil
}
