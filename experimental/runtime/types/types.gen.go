// Code generated by oapi-codegen; DO NOT EDIT.

package types

import (
	"bytes"
	"encoding/json"
	"errors"
	"io"
	"mime/multipart"
	"regexp"
	"time"

	"github.com/google/uuid"
)

const DateFormat = "2006-01-02"

type Date struct {
	time.Time
}

func (d Date) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Format(DateFormat))
}

func (d *Date) UnmarshalJSON(data []byte) error {
	var dateStr string
	err := json.Unmarshal(data, &dateStr)
	if err != nil {
		return err
	}
	parsed, err := time.Parse(DateFormat, dateStr)
	if err != nil {
		return err
	}
	d.Time = parsed
	return nil
}

func (d Date) String() string {
	return d.Format(DateFormat)
}

func (d *Date) UnmarshalText(data []byte) error {
	parsed, err := time.Parse(DateFormat, string(data))
	if err != nil {
		return err
	}
	d.Time = parsed
	return nil
}

// MarshalText implements encoding.TextMarshaler for Date.
func (d Date) MarshalText() ([]byte, error) {
	return []byte(d.Format(DateFormat)), nil
}

// Format returns the date formatted according to layout.
func (d Date) Format(layout string) string {
	return d.Time.Format(layout)
}

const (
	emailRegexString = "^(?:(?:(?:(?:[a-zA-Z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])+(?:\\.([a-zA-Z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])+)*)|(?:(?:\\x22)(?:(?:(?:(?:\\x20|\\x09)*(?:\\x0d\\x0a))?(?:\\x20|\\x09)+)?(?:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])|(?:(?:[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}]))))*(?:(?:(?:\\x20|\\x09)*(?:\\x0d\\x0a))?(\\x20|\\x09)+)?(?:\\x22))))@(?:(?:(?:[a-zA-Z]|\\d|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])|(?:(?:[a-zA-Z]|\\d|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])(?:[a-zA-Z]|\\d|-|\\.|~|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])*(?:[a-zA-Z]|\\d|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])))\\.)+(?:(?:[a-zA-Z]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])|(?:(?:[a-zA-Z]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])(?:[a-zA-Z]|\\d|-|\\.|~|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])*(?:[a-zA-Z]|[\\x{00A0}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFEF}])))\\.?$"
)

var (
	emailRegex = regexp.MustCompile(emailRegexString)
)

// ErrValidationEmail is the sentinel error returned when an email fails validation
var ErrValidationEmail = errors.New("email: failed to pass regex validation")

// Email represents an email address.
// It is a string type that must pass regex validation before being marshalled
// to JSON or unmarshalled from JSON.
type Email string

func (e Email) MarshalJSON() ([]byte, error) {
	if !emailRegex.MatchString(string(e)) {
		return nil, ErrValidationEmail
	}

	return json.Marshal(string(e))
}

func (e *Email) UnmarshalJSON(data []byte) error {
	if e == nil {
		return nil
	}

	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	*e = Email(s)
	if !emailRegex.MatchString(s) {
		return ErrValidationEmail
	}

	return nil
}

type File struct {
	multipart *multipart.FileHeader
	data      []byte
	filename  string
}

func (file *File) InitFromMultipart(header *multipart.FileHeader) {
	file.multipart = header
	file.data = nil
	file.filename = ""
}

func (file *File) InitFromBytes(data []byte, filename string) {
	file.data = data
	file.filename = filename
	file.multipart = nil
}

func (file File) MarshalJSON() ([]byte, error) {
	b, err := file.Bytes()
	if err != nil {
		return nil, err
	}
	return json.Marshal(b)
}

func (file *File) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, &file.data)
}

func (file File) Bytes() ([]byte, error) {
	if file.multipart != nil {
		f, err := file.multipart.Open()
		if err != nil {
			return nil, err
		}
		defer func() { _ = f.Close() }()
		return io.ReadAll(f)
	}
	return file.data, nil
}

func (file File) Reader() (io.ReadCloser, error) {
	if file.multipart != nil {
		return file.multipart.Open()
	}
	return io.NopCloser(bytes.NewReader(file.data)), nil
}

func (file File) Filename() string {
	if file.multipart != nil {
		return file.multipart.Filename
	}
	return file.filename
}

func (file File) FileSize() int64 {
	if file.multipart != nil {
		return file.multipart.Size
	}
	return int64(len(file.data))
}

// Nullable is a generic type that can distinguish between:
// - Field not provided (unspecified)
// - Field explicitly set to null
// - Field has a value
//
// This is implemented as a map[bool]T where:
// - Empty map: unspecified
// - map[false]T: explicitly null
// - map[true]T: has a value
type Nullable[T any] map[bool]T

// NewNullableWithValue creates a Nullable with the given value.
func NewNullableWithValue[T any](value T) Nullable[T] {
	return Nullable[T]{true: value}
}

// NewNullNullable creates a Nullable that is explicitly null.
func NewNullNullable[T any]() Nullable[T] {
	return Nullable[T]{false: *new(T)}
}

// Get returns the value if set, or an error if null or unspecified.
func (n Nullable[T]) Get() (T, error) {
	if v, ok := n[true]; ok {
		return v, nil
	}
	var zero T
	if n.IsNull() {
		return zero, ErrNullableIsNull
	}
	return zero, ErrNullableNotSpecified
}

// MustGet returns the value or panics if null or unspecified.
func (n Nullable[T]) MustGet() T {
	v, err := n.Get()
	if err != nil {
		panic(err)
	}
	return v
}

// Set assigns a value.
func (n *Nullable[T]) Set(value T) {
	*n = Nullable[T]{true: value}
}

// SetNull marks the field as explicitly null.
func (n *Nullable[T]) SetNull() {
	*n = Nullable[T]{false: *new(T)}
}

// SetUnspecified clears the field (as if it was never set).
func (n *Nullable[T]) SetUnspecified() {
	*n = nil
}

// IsNull returns true if the field is explicitly null.
func (n Nullable[T]) IsNull() bool {
	if n == nil {
		return false
	}
	_, ok := n[false]
	return ok
}

// IsSpecified returns true if the field was provided (either null or a value).
func (n Nullable[T]) IsSpecified() bool {
	return len(n) > 0
}

// MarshalJSON implements json.Marshaler.
func (n Nullable[T]) MarshalJSON() ([]byte, error) {
	if n.IsNull() {
		return []byte("null"), nil
	}
	if v, ok := n[true]; ok {
		return json.Marshal(v)
	}
	// Unspecified - this shouldn't be called if omitempty is used correctly
	return []byte("null"), nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (n *Nullable[T]) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		n.SetNull()
		return nil
	}
	var v T
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	n.Set(v)
	return nil
}

// ErrNullableIsNull is returned when trying to get a value from a null Nullable.
var ErrNullableIsNull = errors.New("nullable value is null")

// ErrNullableNotSpecified is returned when trying to get a value from an unspecified Nullable.
var ErrNullableNotSpecified = errors.New("nullable value is not specified")

type UUID = uuid.UUID
